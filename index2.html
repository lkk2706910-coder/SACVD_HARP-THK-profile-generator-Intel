<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SACVD_HARP THK profile generator</title>
    <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .stats-val { font-variant-numeric: tabular-nums; }
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-thumb { background: #94a3b8; border-radius: 3px; }
        ::-webkit-scrollbar-track { background: #e2e8f0; }
        .spinner { width: 24px; height: 24px; border: 3px solid #e2e8f0; border-top-color: #3b82f6; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        body { overscroll-behavior-y: none; }
    </style>
</head>
<body class="bg-slate-100 text-slate-800 h-[100dvh] w-screen overflow-hidden flex flex-col">

<header class="bg-white shadow-sm z-30 p-2 md:p-3 flex justify-between items-center shrink-0 border-b border-slate-200">
    <div class="flex items-center gap-2 md:gap-3 overflow-hidden">
        <h1 class="text-base md:text-lg font-bold text-slate-800 tracking-tight whitespace-nowrap">WAFER <span class="text-blue-600">PRO</span></h1>
        <span class="hidden md:inline-block text-xs bg-slate-100 text-slate-500 px-2 py-1 rounded font-mono">SACVD/HARP</span>
    </div>
    <div class="flex bg-slate-100 p-1 rounded-lg overflow-x-auto max-w-[200px] md:max-w-none no-scrollbar">
        <div id="slotSelector" class="flex gap-1"></div>
    </div>
</header>

<div class="flex flex-col md:flex-row flex-1 overflow-hidden relative">

    <aside class="order-2 md:order-1 w-full md:w-80 bg-white border-t md:border-t-0 md:border-r border-slate-200 flex flex-col shrink-0 z-20 shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.1)] md:shadow-sm h-[40%] md:h-auto transition-all duration-300">
        
        <div class="p-3 border-b border-slate-100 bg-slate-50/80 backdrop-blur flex justify-between items-center sticky top-0 z-10">
            <div>
                <h2 class="text-[10px] font-bold text-slate-500 uppercase">Values (Å)</h2>
                <div class="text-[10px] text-slate-400 flex gap-1">
                    Slot <span id="currentSlotDisplay" class="font-bold text-blue-600">A</span>
                    <span class="md:hidden">• Scroll to edit</span>
                </div>
            </div>
            <button onclick="togglePasteArea()" class="md:hidden text-blue-600 text-xs font-bold px-2 py-1 bg-blue-50 rounded border border-blue-100">
                Paste Data
            </button>
        </div>

        <div id="pasteSection" class="hidden md:block p-3 border-b border-slate-100 bg-slate-50">
            <textarea id="pasteArea" class="w-full h-16 md:h-20 text-xs font-mono p-2 border border-slate-300 rounded bg-white focus:ring-2 focus:ring-blue-500 outline-none resize-none" placeholder="Paste Excel column..."></textarea>
            <button onclick="autoExtract()" class="mt-2 w-full bg-blue-600 hover:bg-blue-700 text-white text-xs font-bold py-2 rounded shadow-sm transition flex items-center justify-center gap-2 active:bg-blue-800">
                <span>⚡</span> Parse Data
            </button>
        </div>
        
        <div class="flex-1 overflow-y-auto bg-white p-2">
            <div id="pointInputs" class="grid grid-cols-2 md:grid-cols-1 gap-x-3 gap-y-1"></div>
        </div>
    </aside>

    <main class="order-1 md:order-2 flex-1 relative bg-slate-50 flex flex-col overflow-hidden w-full">
        
        <div class="flex-1 flex items-center justify-center p-2 md:p-4 min-h-0">
            <div id="waferPlot" class="w-full h-full max-w-[800px]"></div>
        </div>

        <div class="bg-white border-t border-slate-200 p-2 md:p-4 shrink-0 shadow-inner z-10">
            <div class="max-w-6xl mx-auto flex flex-col xl:flex-row gap-3 items-center justify-between">
                <div id="bottomStats" class="flex flex-nowrap md:flex-wrap gap-2 overflow-x-auto w-full md:w-auto pb-2 md:pb-0 px-1 justify-start md:justify-start no-scrollbar">
                    </div>
                
                <button onclick="openComparison()" class="w-full md:w-auto bg-slate-800 hover:bg-black text-white text-xs md:text-sm font-bold px-4 py-3 md:py-2.5 rounded-lg shadow-lg transition transform active:scale-95 flex items-center justify-center gap-2 whitespace-nowrap">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z"></path></svg>
                    Compare All Slots (5)
                </button>
            </div>
        </div>
    </main>
</div>

<div id="compModal" class="fixed inset-0 bg-slate-900/95 backdrop-blur-md z-50 hidden flex flex-col">
    <div class="flex justify-between items-center px-4 md:px-6 py-3 md:py-4 bg-white/5 border-b border-white/10 shrink-0">
        <div>
            <h2 class="text-lg md:text-xl font-bold text-white tracking-tight">Fleet View</h2>
        </div>
        <button onclick="closeComparison()" class="bg-white/10 hover:bg-red-500/80 p-2 rounded-full transition active:scale-90">
            <svg class="w-5 h-5 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" /></svg>
        </button>
    </div>
    <div class="flex-1 overflow-y-auto p-3 md:p-8">
        <div id="compGrid" class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-5 gap-4 md:gap-6 max-w-[1800px] mx-auto pb-10"></div>
    </div>
</div>

<script>
    // --- 座標配置 ---
    const WAFER_RADIUS = 148; 
    const config = {
        X: [0.0, 0.0001, -0.0001, 104.6513, -104.6513, -104.652, 104.6522, 128.1713, -128.1713, -128.1719, 128.172, 142.9568, -142.9568, 142.957, -142.957, 148, -148, -0.0002, 34.8837, -34.8837, 34.884, -34.884, 37.7577, -37.7577, 37.7584, -37.7584, 38.3045, -38.3045, 38.3057, -38.3057, 0.0004, 49.3332, -49.3332, 0.0005, -0.0005, 69.7674, -69.7675, -69.768, 69.7681, 73.9993, -73.9993, -74.0003, 74.0005, 91.1559, -91.1559, 91.1562, -91.1562, 98.6666, -98.6666],
        Y: [0.0, -49.3332, 49.3332, 104.6522, -104.6522, 104.6513, -104.6513, 74.0005, -74.0003, 73.9995, -73.9993, 38.3057, -38.3057, -38.3045, 38.3045, 0.0005, -0.0005, 98.6666, 34.884, -34.884, -34.8837, 34.8837, 91.1562, -91.1562, -91.1559, 91.1559, 142.957, -142.957, -142.9568, 142.9568, -98.6666, 0.0001, -0.0001, -148, 148, 69.7681, -69.768, 69.7675, -69.7675, 128.172, -128.1719, 128.1714, -128.1713, 37.7584, -37.7584, -37.7577, 37.7577, 0.0004, -0.0004]
    };

    let currentSlot = 'A';
    let storage = { 'A': [], 'B': [], 'C': [], 'D': [], 'E': [] };

    function init() {
        const selector = document.getElementById('slotSelector');
        ['A','B','C','D','E'].forEach(s => {
            const btn = document.createElement('button');
            btn.id = `btn-${s}`;
            btn.className = `flex-shrink-0 px-3 md:px-4 py-1.5 text-xs font-bold rounded-lg transition-all ${s==='A'?'bg-blue-600 text-white shadow-md ring-2 ring-blue-200':'text-slate-500 hover:bg-slate-200'}`;
            btn.textContent = `Slot ${s}`;
            btn.onclick = () => switchSlot(s);
            selector.appendChild(btn);
            storage[s] = new Array(config.X.length).fill("");
        });
        refreshInputs();
        drawPlot();
        window.addEventListener('resize', () => { Plotly.Plots.resize('waferPlot'); });
    }

    function switchSlot(slot) {
        currentSlot = slot;
        document.getElementById('currentSlotDisplay').textContent = slot;
        document.querySelectorAll('#slotSelector button').forEach(b => b.className = "flex-shrink-0 px-3 md:px-4 py-1.5 text-xs font-bold rounded-lg transition-all text-slate-500 hover:bg-slate-200");
        document.getElementById(`btn-${slot}`).className = "flex-shrink-0 px-3 md:px-4 py-1.5 text-xs font-bold rounded-lg transition-all bg-blue-600 text-white shadow-md ring-2 ring-blue-200";
        refreshInputs();
        drawPlot();
    }

    function togglePasteArea() {
        document.getElementById('pasteSection').classList.toggle('hidden');
    }

    function refreshInputs() {
        const container = document.getElementById('pointInputs');
        container.innerHTML = '';
        storage[currentSlot].forEach((val, i) => {
            const div = document.createElement('div');
            div.className = "flex items-center gap-1 group bg-slate-50 p-1 rounded border border-slate-100";
            div.innerHTML = `
                <span class="text-[9px] font-mono text-slate-400 w-5 text-right shrink-0">#${(i+1)}</span>
                <input type="number" class="w-full bg-white border border-transparent focus:border-blue-500 focus:ring-1 focus:ring-blue-200 rounded px-1.5 py-1 text-xs font-bold text-slate-700 outline-none text-right transition" 
                       placeholder="-" value="${val}" oninput="storage['${currentSlot}'][${i}]=this.value; delayedDraw()">
            `;
            container.appendChild(div);
        });
    }

    function delayedDraw() {
        if(window.redrawTimeout) clearTimeout(window.redrawTimeout);
        window.redrawTimeout = setTimeout(drawPlot, 300); 
    }

    function autoExtract() {
        const text = document.getElementById('pasteArea').value;
        if(window.innerWidth < 768) document.getElementById('pasteSection').classList.add('hidden');
        const numbers = text.match(/[-+]?\d*\.\d+|\d+/g);
        if (!numbers) return;
        const count = config.X.length;
        const target = numbers.length >= count ? numbers.slice(-count) : numbers;
        target.forEach((num, i) => { if(i < count) storage[currentSlot][i] = num; });
        document.getElementById('pasteArea').value = '';
        refreshInputs();
        drawPlot();
    }

    // --- Statistics ---
    function calculateStats(vals) {
        const valid = vals.filter(v => v !== "" && !isNaN(v)).map(Number);
        const n = valid.length;
        if (!n) return null;
        const avg = valid.reduce((a,b)=>a+b,0) / n;
        const min = Math.min(...valid);
        const max = Math.max(...valid);
        const rng = max - min;
        let stdDev = 0;
        if (n > 1) {
            const sumSqDiff = valid.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0);
            stdDev = Math.sqrt(sumSqDiff / (n - 1));
        }
        const uPct = avg ? (stdDev / avg * 100) : 0;
        return { avg, min, max, rng, uPct };
    }

    // --- Mask Generation (Ring Polygon) ---
    function getSolidRing(innerR, outerR) {
        const x = [], y = [];
        const steps = 120;
        for(let i=0; i<=steps; i++) { // Outer CCW
            const theta = (i/steps) * 2 * Math.PI;
            x.push(outerR * Math.cos(theta));
            y.push(outerR * Math.sin(theta));
        }
        for(let i=0; i<=steps; i++) { // Inner CW
            const theta = 2 * Math.PI - (i/steps) * 2 * Math.PI;
            x.push(innerR * Math.cos(theta));
            y.push(innerR * Math.sin(theta));
        }
        // Close
        x.push(outerR * Math.cos(0));
        y.push(outerR * Math.sin(0));
        return { x, y };
    }
    
    function getCircleBorder(r) {
        const x = [], y = [];
        const steps = 120;
        for(let i=0; i<=steps; i++) {
            const theta = (i/steps) * 2 * Math.PI;
            x.push(r * Math.cos(theta));
            y.push(r * Math.sin(theta));
        }
        return {x,y};
    }

    // --- Interpolation (Bleed Enabled) ---
    function interpolateGrid(xPoints, yPoints, zValues, resolution = 100) { 
        const validIndices = zValues.map((v, i) => (v !== "" && !isNaN(v)) ? i : -1).filter(i => i !== -1);
        if (validIndices.length < 3) return null;

        const xGrid = [], yGrid = [], zGrid = [];
        const step = 320 / resolution; 
        
        // Bleed well past the wafer radius (148 -> 156)
        const R_BLEED = WAFER_RADIUS + 8; 

        for (let i = 0; i <= resolution; i++) {
            const y = -160 + i * step;
            yGrid.push(y);
            const rowZ = [];
            for (let j = 0; j <= resolution; j++) {
                const x = -160 + j * step;
                if (i === 0) xGrid.push(x);
                
                if (Math.sqrt(x*x + y*y) > R_BLEED) { rowZ.push(null); continue; }
                
                let num = 0, den = 0, exact = null;
                for (let k of validIndices) {
                    const dx = x - xPoints[k];
                    const dy = y - yPoints[k];
                    const d2 = dx*dx + dy*dy;
                    if (d2 < 1) { exact = zValues[k]; break; }
                    const w = 1 / (d2 * d2); 
                    num += zValues[k] * w; den += w;
                }
                rowZ.push(exact !== null ? exact : num / den);
            }
            zGrid.push(rowZ);
        }
        return { x: xGrid, y: yGrid, z: zGrid };
    }

    // --- ★★★ NEW: Dynamic Text Positioning Logic ★★★ ---
    function getTextPositions(xArr, yArr) {
        return xArr.map((x, i) => {
            const y = yArr[i];
            const r = Math.sqrt(x*x + y*y);
            
            // 內部點：保持在上方 (標準)
            if (r < 120) return 'top center';
            
            // 邊緣點：強制向圓心內縮 (Inward)
            // 邏輯：y>0(上方點)則文字放bottom，y<0(下方點)則文字放top
            let v = y > 20 ? 'bottom' : (y < -20 ? 'top' : 'middle');
            let h = x > 20 ? 'left' : (x < -20 ? 'right' : 'center');
            
            // 修正垂直與水平軸附近的點，避免對齊偏移
            if (Math.abs(x) < 20) h = 'center';
            if (Math.abs(y) < 20) v = 'middle';
            
            return `${v} ${h}`;
        });
    }

    function drawPlot() {
        const vals = storage[currentSlot];
        const stats = calculateStats(vals);
        const statDiv = document.getElementById('bottomStats');

        if (stats) {
            const item = (lbl, val, unit, color) => `
                <div class="px-3 py-1.5 md:px-4 md:py-2 bg-slate-100 rounded-lg border border-slate-200 text-center min-w-[80px] md:min-w-[110px] shrink-0">
                    <div class="text-[8px] md:text-[9px] font-bold text-slate-500 uppercase tracking-wider">${lbl}</div>
                    <div class="text-sm md:text-base font-black ${color||'text-slate-800'}">${val}<span class="text-[9px] md:text-[10px] font-normal text-slate-400 ml-0.5">${unit}</span></div>
                </div>`;
            statDiv.innerHTML = 
                item('THK', stats.avg.toFixed(1), 'Å') +
                item('Unif', stats.uPct.toFixed(2), '%', 'text-blue-600') +
                item('Range', stats.rng.toFixed(1), 'Å') +
                item('Max', stats.max.toFixed(1), 'Å', 'text-red-600') +
                item('Min', stats.min.toFixed(1), 'Å', 'text-emerald-600');
        } else {
            statDiv.innerHTML = `<div class="text-slate-400 font-bold text-xs md:text-sm italic py-2 px-2">No data</div>`;
        }

        const gridData = interpolateGrid(config.X, config.Y, vals, 100);
        renderPlotly('waferPlot', gridData, vals, { showPoints: true, pointSize: 10, bgColor: '#f8fafc' });
    }

    function renderPlotly(divId, gridData, rawVals, opts = {}) {
        const plotDiv = document.getElementById(divId);
        const isMobile = window.innerWidth < 768;
        const pSize = isMobile ? 8 : (opts.pointSize || 10);
        const bgColor = opts.bgColor || '#ffffff';

        if (!gridData) {
            Plotly.newPlot(divId, [], { xaxis: {visible:false}, yaxis: {visible:false}, title: {text:'No Data', font:{color:'#cbd5e1'}} }, {responsive: true});
            return;
        }

        // ★★★ 計算所有點的文字位置 ★★★
        const textPosArr = getTextPositions(config.X, config.Y);

        const traces = [];

        // 1. Contour Trace (Bottom)
        traces.push({
            x: gridData.x, y: gridData.y, z: gridData.z,
            type: 'contour', colorscale: 'Jet', ncontours: 40,
            line: { width: 0 }, contours: { coloring: 'heatmap', showlabels: false },
            zsmooth: 'best', showscale: opts.showScale ?? !isMobile, 
            colorbar: { title: 'Å', thickness: 15 }
        });

        // 2. Mask Trace (Middle)
        const ringData = getSolidRing(148, 175);
        traces.push({
            x: ringData.x, y: ringData.y,
            type: 'scatter', mode: 'lines', fill: 'toself',
            fillcolor: bgColor, 
            line: { width: 0, color: 'transparent' },
            hoverinfo: 'skip',
            showlegend: false
        });

        // 3. Black Border Trace (Top of Mask)
        const borderData = getCircleBorder(148);
        traces.push({
            x: borderData.x, y: borderData.y,
            type: 'scatter', mode: 'lines',
            line: { width: 2, color: 'black' },
            hoverinfo: 'skip',
            showlegend: false
        });

        // 4. Data Labels (Very Top)
        if (opts.showPoints) {
            traces.push({
                x: config.X, y: config.Y,
                mode: 'markers+text', type: 'scatter',
                text: rawVals.map(v => v ? Math.round(v) : ''),
                textfont: { size: pSize, color: 'black', weight: 'bold', family: 'Arial' },
                
                // ★★★ 使用動態計算的位置，確保文字在圈內 ★★★
                textposition: textPosArr,
                
                marker: { size: isMobile ? 3 : 4, color: 'rgba(0,0,0,0.5)', line: {color: 'white', width: 1} },
                hoverinfo: 'none',
                showlegend: false
            });
        }

        const layout = {
            margin: { t: 20, b: 20, l: 20, r: 20 },
            // 範圍稍微縮小回 155 (因為文字現在都在內部了，不需要留那麼多白邊)
            xaxis: { range: [-155, 155], visible: false, fixedrange: true },
            yaxis: { range: [-155, 155], visible: false, scaleanchor: "x", fixedrange: true },
            plot_bgcolor: 'rgba(0,0,0,0)', paper_bgcolor: 'rgba(0,0,0,0)',
            hovermode: false,
            showlegend: false
        };

        Plotly.react(divId, traces, layout, {displayModeBar: false, responsive: true});
    }

    // --- Fleet View ---
    function openComparison() {
        document.getElementById('compModal').classList.remove('hidden');
        const grid = document.getElementById('compGrid');
        grid.innerHTML = ''; 

        ['A','B','C','D','E'].forEach((slot, idx) => {
            const card = document.createElement('div');
            card.className = "bg-white rounded-xl overflow-hidden shadow-lg border border-slate-200 flex flex-col h-[350px] md:h-[480px]";
            card.innerHTML = `
                <div class="bg-slate-50 px-4 py-2 border-b border-slate-100 flex justify-between items-center shrink-0">
                    <span class="font-black text-slate-700 text-base md:text-lg">Slot ${slot}</span>
                </div>
                <div id="comp-plot-${slot}" class="flex-1 bg-white relative">
                    <div class="absolute inset-0 flex items-center justify-center spinner-box"><div class="spinner"></div></div>
                </div>
                <div id="comp-stat-${slot}" class="bg-slate-50 border-t border-slate-100 px-2 py-2 md:px-3 md:py-3 grid grid-cols-2 gap-2 shrink-0"></div>
            `;
            grid.appendChild(card);

            setTimeout(() => {
                try {
                    const plotContainer = document.getElementById(`comp-plot-${slot}`);
                    const vals = storage[slot];
                    const stats = calculateStats(vals);
                    const statFooter = document.getElementById(`comp-stat-${slot}`);
                    
                    if (stats) {
                        const mini = (lbl, val, color) => `
                            <div class="bg-white p-1 md:p-1.5 rounded border border-slate-100 text-center">
                                <div class="text-[7px] md:text-[8px] font-bold text-slate-400 uppercase">${lbl}</div>
                                <div class="text-[10px] md:text-xs font-black ${color||'text-slate-700'}">${val}</div>
                            </div>`;
                        statFooter.innerHTML = 
                            mini('THK', stats.avg.toFixed(0)) +
                            mini('Unif', stats.uPct.toFixed(2)+'%', 'text-blue-600') +
                            mini('Rng', stats.rng.toFixed(0)) +
                            mini('Max/Min', stats.max.toFixed(0)+'/'+stats.min.toFixed(0), 'text-slate-500');

                        plotContainer.querySelector('.spinner-box')?.remove();
                        const gridData = interpolateGrid(config.X, config.Y, vals, 50); 
                        renderPlotly(`comp-plot-${slot}`, gridData, vals, { showPoints: true, pointSize: 6, showScale: false, bgColor: '#ffffff' });
                    } else {
                        plotContainer.innerHTML = `<div class="flex items-center justify-center h-full text-slate-300 font-bold text-xs">EMPTY</div>`;
                        statFooter.innerHTML = `<div class="col-span-2 text-center text-[10px] text-slate-300 py-1">NO DATA</div>`;
                    }
                } catch (e) { console.error(e); }
            }, 100 + (idx * 150));
        });
    }

    function closeComparison() {
        document.getElementById('compModal').classList.add('hidden');
    }

    window.onload = init;
</script>
</body>
</html>